# Example Tasks for a "Hello, World!" Project

This file outlines a set of tasks for building a simple Next.js project. In this project, the user enters their name in a text box on the Home Page and is then greeted with "Hello, {name}" on a separate Greeting Page.

Here's an example prompt to use to generate this. Note that you'll first want to either provide a detailed set of notes / prd of exactly what to build, or have a two-step process where you have the AI create the spec, then proceed with this step:
Be sure to use an advanced thinking model with this, ideally "Deep Research" from OpenAI but o1-pro, o3-mini, flash-2-thinking, or (maybe?) DeepSeek R1 could work as well. 

``` txt
Create a very very very detailed markdown checklist of all of the stories for this project plan, with one-story-point tasks (with unchecked checkboxes) that break down each story. It is critically important that all of the details to implement this are in this list. Note that a very competent AI Coding Agent will be using this list to autonomously create this application, so be sure not to miss any details whatsoever, no matter how much time and thinking you must do to complete this very challenging but critically important task.
```

After you generate this task list, here is a prompt to use in cursor agent to kick this off (might be useful to put at the end of your cursorrules file as well?)
Probably helpful to just @include the cursor-tasks.md file as well. 
``` txt
Go through each story and task in the .cursor-tasks.md file. Find the next story to work on. Review each unfinished task, correct any issues or ask for clarifications (only if absolutely needed!). Then proceed to create or edit files to complete each task. After you complete all the tasks in the story, update the file to check off any completed tasks. Run builds and commits after each story. Run all safe commands without asking for approval. Continue with each task until you have finished the story, then stop and wait for me to review.
```

---
Of course. Here is a comprehensive and meticulously detailed markdown checklist of all the user stories and one-story-point tasks required to build the dance costume marketplace. This plan is designed to be used by a competent AI Coding Agent for autonomous application development.

### **Project: "Second Act" - A Marketplace for Used Dance Costumes**

---

### **Epic: User Account Management & Profiles**

This epic covers all functionality related to user authentication, account creation, and profile management.

*   **Story: As a new user, I want to create a secure account so that I can buy and sell costumes.**
    *   [ ] **Database:** Create a `users` table with columns: `id` (PK, UUID), `first_name` (VARCHAR), `last_name` (VARCHAR), `username` (VARCHAR, UNIQUE), `email` (VARCHAR, UNIQUE), `password_hash` (VARCHAR), `profile_picture_url` (VARCHAR), `created_at` (TIMESTAMP), `updated_at` (TIMESTAMP).
    *   [ ] **UI/UX:** Design the user registration page with input fields for First Name, Last Name, Username, Email, Password, and a "Confirm Password" field.
    *   [ ] **Frontend:** Implement client-side validation for the registration form (e.g., check for empty fields, valid email format, and password strength requirements - min 8 characters, 1 number, 1 special character).
    *   [ ] **Backend API:** Create a RESTful endpoint `POST /api/v1/auth/register` to handle new user submissions.
    *   [ ] **Backend Logic:** Implement server-side validation to ensure username and email are unique in the database.
    *   [ ] **Backend Security:** Hash the user's password using a strong algorithm like bcrypt before saving it to the database. Never store plain-text passwords.
    *   [ ] **Backend JWT:** Upon successful registration, generate a JSON Web Token (JWT) for the new user and return it in the response.
    *   [ ] **Email Service:** Integrate an email service (e.g., SendGrid, Mailgun) and send a "Welcome to Second Act!" email to the user's provided address upon successful registration.
    *   [ ] **Frontend Logic:** After a successful registration API response, store the JWT securely (e.g., in an HttpOnly cookie) and redirect the user to their new dashboard.
    *   [ ] **Testing:** Write unit tests for the registration endpoint, checking for successful creation and handling of duplicate email/username errors.

*   **Story: As an existing user, I want to log in to my account so that I can access my dashboard.**
    *   [ ] **UI/UX:** Design the user login page with input fields for Email/Username and Password, and a "Forgot Password?" link.
    *   [ ] **Frontend:** Implement client-side validation for the login form (e.g., check for empty fields).
    *   [ ] **Backend API:** Create a RESTful endpoint `POST /api/v1/auth/login` to handle user authentication.
    *   [ ] **Backend Logic:** In the login handler, find the user by their email/username and verify the provided password against the stored `password_hash` using bcrypt's compare function.
    *   [ ] **Backend JWT:** If authentication is successful, generate a new JWT and return it in the response.
    *   [ ] **Frontend Logic:** Upon successful login, store the JWT securely and redirect the user to their dashboard or the page they were trying to access.
    *   [ ] **Testing:** Write unit tests for the login endpoint, checking for both successful and failed authentication attempts.

*   **Story: As a user who forgot my password, I want to reset it securely.**
    *   [ ] **Database:** Add columns to the `users` table: `password_reset_token` (VARCHAR) and `password_reset_expires` (TIMESTAMP).
    *   [ ] **UI/UX:** Design a "Forgot Password" page that takes a user's email address.
    *   [ ] **Backend API:** Create an endpoint `POST /api/v1/auth/forgot-password`.
    *   [ ] **Backend Logic:** This endpoint should generate a unique, cryptographic, time-sensitive reset token, store its hash and expiration in the database for the user, and email the user a reset link containing the token.
    *   [ ] **UI/UX:** Design a "Reset Password" page with "New Password" and "Confirm New Password" fields. This page is accessed via the link from the email.
    *   [ ] **Backend API:** Create an endpoint `POST /api/v1/auth/reset-password/:token`.
    *   [ ] **Backend Logic:** This endpoint will validate the token from the URL, check that it has not expired, update the user's `password_hash` with the new hashed password, and then invalidate the reset token.
    *   [ ] **Testing:** Write unit tests for both the `forgot-password` and `reset-password` flows.

*   **Story: As a user, I want to manage my public profile.**
    *   [ ] **UI/UX:** Design the "Edit Profile" page with fields to update first name, last name, username, and upload a new profile picture.
    *   [ ] **UI/UX:** Design the public view of a user's profile, which displays their username, profile picture, join date, and average seller rating.
    *   [ ] **Cloud Storage:** Set up a cloud storage bucket (e.g., AWS S3, Google Cloud Storage) for user-uploaded images.
    *   [ ] **Frontend:** Implement image upload functionality, including a preview of the selected image.
    *   [ ] **Backend API:** Create an endpoint `GET /api/v1/users/profile` to fetch the logged-in user's profile data.
    *   [ ] **Backend API:** Create an endpoint `PUT /api/v1/users/profile` to handle updates to profile information, including the profile picture URL.
    *   [ ] **Backend Logic:** Implement image resizing/optimization for uploaded profile pictures before storing them.
    *   [ ] **Testing:** Write unit tests for fetching and updating user profiles.

---

### **Epic: Seller Features**

This epic covers all functionality for users listing and managing their costumes for sale.

*   **Story: As a seller, I want to create a detailed costume listing.**
    *   [ ] **Database:** Create a `costumes` table (`id`, `seller_id` (FK to users), `title`, `description`, `price` (DECIMAL), `size` (VARCHAR), `condition` (ENUM: 'New', 'Like New', 'Good', 'Fair'), `status` (ENUM: 'available', 'sold'), `created_at`, `updated_at`).
    *   [ ] **Database:** Create a `costume_categories` table (`id`, `name`). Pre-populate with styles: Ballet, Jazz, Tap, Lyrical, Contemporary, Hip-Hop, etc.
    *   [ ] **Database:** Create a `costume_to_category` join table (`costume_id`, `category_id`).
    *   [ ] **Database:** Create a `costume_images` table (`id`, `costume_id` (FK to costumes), `image_url`, `is_primary` (BOOLEAN)).
    *   [ ] **UI/UX:** Design a multi-step "Create Listing" form.
    *   [ ] **Frontend (Step 1):** Implement form fields for Title (text input), Description (textarea), and Categories (multi-select checkboxes).
    *   [ ] **Frontend (Step 2):** Implement form fields for Price (numeric input), Size (dropdown: Child S/M/L, Adult XS/S/M/L/XL), and Condition (radio buttons).
    *   [ ] **Frontend (Step 3):** Implement a multi-file uploader with drag-and-drop support, image previews, and the ability to reorder images and select one as the primary display image.
    *   [ ] **Frontend (Step 4):** Implement form fields for shipping options and costs.
    *   [ ] **Frontend:** Implement comprehensive client-side validation for all fields.
    *   [ ] **Backend API:** Create an endpoint `POST /api/v1/costumes` to handle the creation of a new listing.
    *   [ ] **Backend Logic:** The endpoint must handle the upload of multiple images to the cloud storage bucket.
    *   [ ] **Backend Logic:** The endpoint must create the main `costume` record and then create associated records in `costume_images` and `costume_to_category`.
    *   [ ] **Frontend Logic:** On successful submission, redirect the seller to the newly created listing's public page.
    *   [ ] **Testing:** Write unit tests for the listing creation endpoint, including image handling.

*   **Story: As a seller, I want to manage my active and sold listings.**
    *   [ ] **UI/UX:** Design a "My Listings" dashboard page with tabs for "Active" and "Sold".
    *   [ ] **UI/UX:** Each listing in the dashboard view should show its primary image, title, price, and current status.
    *   [ ] **Backend API:** Create an endpoint `GET /api/v1/users/me/costumes` to fetch all listings for the currently authenticated seller.
    *   [ ] **Frontend:** Implement an "Edit" button for each active listing that navigates to a pre-filled version of the "Create Listing" form.
    *   [ ] **Backend API:** Create an endpoint `GET /api/v1/costumes/:id` to fetch data for a single costume.
    *   [ ] **Backend API:** Create an endpoint `PUT /api/v1/costumes/:id` to handle updates to an existing listing. Ensure a user can only edit their own listings.
    *   [ ] **Frontend:** Implement a "Delete" button for active listings, which triggers a confirmation modal before proceeding.
    *   [ ] **Backend API:** Create an endpoint `DELETE /api/v1/costumes/:id`. Ensure a user can only delete their own listings.
    *   [ ] **Backend Logic:** Ensure that a listing cannot be edited or deleted once it has been sold.

---

### **Epic: Buyer Features**

This epic covers all functionality for users to discover, view, and purchase costumes.

*   **Story: As a buyer, I want to easily find costumes using search and filters.**
    *   [ ] **UI/UX:** Design the homepage to feature a prominent search bar and a grid of costume categories.
    *   [ ] **UI/UX:** Design the search results page with a grid/list view of costumes and a sidebar for filtering options.
    *   [ ] **Backend API:** Create a search endpoint `GET /api/v1/costumes/search` that supports a query parameter for full-text search on `title` and `description`.
    *   [ ] **Frontend:** Implement the filter sidebar UI with controls for: Category (checkboxes), Size (checkboxes), Price Range (a dual-handle slider), and Condition (checkboxes).
    *   [ ] **Backend Logic:** Enhance the search endpoint to accept and apply filter parameters to the database query.
    *   [ ] **Backend Logic:** Implement pagination on the search endpoint to handle large result sets efficiently (e.g., returning 24 items per page).
    *   [ ] **Frontend Logic:** Update the search results dynamically as filters are applied, without requiring a full page reload.

*   **Story: As a buyer, I want to view all the details of a specific costume.**
    *   [ ] **UI/UX:** Design the Product Detail Page.
    *   [ ] **Frontend:** Display a main image gallery with thumbnails. Clicking a thumbnail should update the main image view.
    *   [ ] **Frontend:** Clearly display the costume's title, price, size, condition, and detailed description.
    *   [ ] **Frontend:** Display the seller's username (linked to their public profile) and their average rating.
    *   [ ] **Frontend:** Display shipping information.
    *   [ ] **Frontend:** Include a prominent "Add to Cart" button.

*   **Story: As a buyer, I want to use a shopping cart and complete a secure purchase.**
    *   [ ] **UI/UX:** Implement a shopping cart icon in the site header that updates with the number of items.
    *   [ ] **Frontend:** Implement client-side state management for the shopping cart.
    *   [ ] **UI/UX:** Design the shopping cart page, showing a list of items with options to remove them. Display subtotal, shipping, and total.
    *   [ ] **UI/UX:** Design a multi-step or single-page checkout flow that collects a shipping address.
    *   [ ] **Database:** Create an `orders` table (`id`, `buyer_id`, `total_price`, `status`, `shipping_address`, `created_at`).
    *   [ ] **Database:** Create an `order_items` table (`id`, `order_id`, `costume_id`, `price_at_purchase`).
    *   [ ] **Payment Gateway:** Integrate Stripe Connect to handle marketplace payments.
    *   [ ] **Frontend:** Implement Stripe Elements for securely collecting credit card information on the client-side. The credit card info should never touch your server.
    *   [ ] **Backend API:** Create an endpoint `POST /api/v1/checkout` to process the order.
    *   [ ] **Backend Logic:** The checkout endpoint must:
        *   1. Create a `PaymentIntent` with Stripe.
        *   2. On successful payment confirmation from Stripe, create records in the `orders` and `order_items` tables.
        *   3. Use Stripe Connect's API to correctly route the payment, taking the platform's commission and designating the rest for the seller's connected account.
        *   4. Update the status of the purchased `costume` to 'sold' to prevent it from being bought again.
        *   5. Send an order confirmation email to the buyer.
        *   6. Send a "You've made a sale!" notification email to the seller.

*   **Story: As a buyer, I want to view my order history.**
    *   [ ] **UI/UX:** Design a "My Orders" page for buyers to see a list of past purchases.
    *   [ ] **Backend API:** Create an endpoint `GET /api/v1/users/me/orders` to fetch the logged-in user's order history.
    *   [ ] **Frontend:** Display key information for each order: order date, order total, and status (e.g., 'Processing', 'Shipped').

---

### **Epic: Trust, Communication & Administration**

This epic covers features that build trust in the community and tools for site administration.

*   **Story: As a user, I want to communicate with another user about a listing.**
    *   [ ] **Database:** Create a `conversations` table (`id`) and a `messages` table (`id`, `conversation_id`, `sender_id`, `receiver_id`, `body`, `created_at`, `is_read`).
    *   [ ] **UI/UX:** Add a "Contact Seller" button on the costume detail page.
    *   [ ] **UI/UX:** Design a dedicated messaging interface with a list of conversations on the left and the selected message thread on the right.
    *   [ ] **Backend API:** Create endpoints for `GET /api/v1/conversations`, `GET /api/v1/conversations/:id/messages`, and `POST /api/v1/conversations/:id/messages`.
    *   [ ] **Backend Logic:** Ensure a new conversation can only be started between a potential buyer and a seller about a specific item.
    *   [ ] **Real-time:** Implement WebSockets (e.g., using Socket.IO) for real-time chat functionality.
    *   [ ] **Notifications:** Send an email notification to a user when they receive a new message.

*   **Story: As a user, I want to leave a review after a transaction is complete.**
    *   [ ] **Database:** Create a `reviews` table (`id`, `order_id`, `reviewer_id`, `reviewee_id`, `rating` (INTEGER 1-5), `comment` (TEXT), `created_at`).
    *   [ ] **Backend Logic:** After an order is completed, create a state that allows a review to be left.
    *   [ ] **UI/UX:** On the "My Orders" page, provide a "Leave a Review" link for completed orders.
    *   [ ] **Frontend:** Implement a review submission form with a 5-star rating input and a comment box.
    *   [ ] **Backend API:** Create an endpoint `POST /api/v1/reviews` to submit a new review. The backend should verify that the reviewer was part of the specified order.
    *   [ ] **Frontend:** On a user's public profile, display their average rating and a list of all reviews they have received.

*   **Story: As a platform owner, I need an admin dashboard to manage the site.**
    *   [ ] **Backend:** Implement role-based access control (RBAC) with 'user' and 'admin' roles.
    *   [ ] **UI/UX:** Design a secure, route-protected admin dashboard.
    *   [ ] **Admin Feature:** Implement a user management view to list, search, and ban users.
    *   [ ] **Admin Feature:** Implement a listing management view to search for and delete inappropriate listings.
    *   [ ] **Admin Feature:** Implement a financial overview to see total sales and platform commissions over time.
    *   [ ] **Admin Feature:** Implement a dispute resolution section where admins can view and mediate issues reported by users.

*   **Story: As a platform owner, I need to handle payments and payouts correctly.**
    *   [ ] **Payment Gateway:** Implement the Stripe Connect onboarding flow, allowing sellers to securely connect their bank account to the platform for receiving payouts.
    *   [ ] **Backend Logic:** Define the platform's commission percentage (e.g., 12%) in a secure configuration file.
    *   [ ] **Database:** Create a `transactions` table to log all financial events, including sales, commissions deducted, and payouts to sellers.
    *   [ ] **Backend Logic:** Set up automated payouts through Stripe's API on a regular schedule (e.g., weekly).

---

### **Epic: Deployment & Foundational Setup**

This epic covers the non-functional requirements for getting the application live.

*   **Story: As a developer, I need to set up the project and deployment pipeline.**
    *   [ ] **Project Setup:** Initialize a new monorepo or two separate repositories (frontend/backend) with a chosen tech stack (e.g., MERN, PERN).
    *   [ ] **Version Control:** Initialize Git and create a remote repository on GitHub or a similar platform.
    *   [ ] **CI/CD:** Create a CI/CD pipeline (e.g., using GitHub Actions) that automatically runs tests on every push and deploys the main branch to production.
    *   [ ] **Infrastructure:** Provision a cloud database (e.g., AWS RDS, MongoDB Atlas).
    *   [ ] **Infrastructure:** Provision a hosting solution (e.g., Vercel for frontend, Heroku/AWS Elastic Beanstalk for backend).
    *   [ ] **Configuration:** Set up environment variables for development, staging, and production environments.
    *   [ ] **Legal:** Create static pages for "Terms and Conditions," "Privacy Policy," and an "About Us" page.
    *   [ ] **SEO:** Implement basic SEO by dynamically setting page titles and meta descriptions, especially for costume listing pages.
    *   [ ] **SEO:** Automatically generate a `sitemap.xml` for better search engine indexing.

    Excellent. Here is the continuation of the very detailed markdown checklist, adding crucial epics and stories for user experience enhancements, advanced seller tools, and platform health. This ensures the AI Coding Agent has a complete roadmap for building a robust, user-friendly, and secure application.

---

### **Epic: User Experience & Engagement Enhancements**

This epic focuses on features that go beyond core functionality to create a more polished, engaging, and sticky user experience.

*   **Story: As a buyer, I want to save costumes I like to a "Wishlist" to view later.**
    *   [ ] **Database:** Create a `user_favorites` join table with columns: `user_id` (FK to users), `costume_id` (FK to costumes), and a composite primary key on (`user_id`, `costume_id`).
    *   [ ] **UI/UX:** Design a "heart" or "save for later" icon. This icon should appear on costume cards in search results and on the costume detail page.
    *   [ ] **Frontend:** The favorite icon's state (favorited/not favorited) should reflect the current user's wishlist status for that item.
    *   [ ] **Backend API:** Create an endpoint `POST /api/v1/costumes/:id/favorite` to add a costume to the logged-in user's favorites.
    *   [ ] **Backend API:** Create an endpoint `DELETE /api/v1/costumes/:id/favorite` to remove a costume from the logged-in user's favorites.
    *   [ ] **UI/UX:** Design a "My Wishlist" page accessible from the user's dashboard.
    *   [ ] **Backend API:** Create an endpoint `GET /api/v1/users/me/favorites` to retrieve all costumes favorited by the logged-in user.
    *   [ ] **Frontend:** Implement the "My Wishlist" page to display a grid of the user's saved items.

*   **Story: As a buyer, I want to sort search results to find relevant items more quickly.**
    *   [ ] **UI/UX:** Design a "Sort By" dropdown menu on the search results page.
    *   [ ] **Frontend:** Populate the dropdown with options: "Newest", "Price: Low to High", "Price: High to Low".
    *   [ ] **Backend API:** Modify the existing `GET /api/v1/costumes/search` endpoint to accept `sortBy` (e.g., 'createdAt', 'price') and `sortOrder` ('asc', 'desc') query parameters.
    *   [ ] **Backend Logic:** Implement the sorting logic in the database query for the search endpoint.
    *   [ ] **Frontend Logic:** When a user selects a sort option, re-trigger the API call with the new sorting parameters and update the displayed results.

*   **Story: As a user, I want to view a seller's public "storefront" to see all their available items.**
    *   [ ] **UI/UX:** On the costume detail page, the seller's username should be a clickable link.
    *   [ ] **UI/UX:** Design a public seller profile page (or "storefront") that displays the seller's profile picture, username, join date, average rating, and a paginated grid of all their *active* listings.
    *   [ ] **Frontend:** Implement a new route `/sellers/:username` for these storefront pages.
    *   [ ] **Backend API:** Create a new endpoint `GET /api/v1/sellers/:username` to fetch public profile data for a given username.
    *   [ ] **Backend API:** Create a new endpoint `GET /api/v1/sellers/:username/costumes` to fetch all *active* costumes listed by that specific user.

*   **Story: As a user, I want to share a costume listing on social media.**
    *   [ ] **UI/UX:** Design a "Share" icon/button on the costume detail page.
    *   [ ] **Frontend:** When the share button is clicked, display a small modal or popover with icons for Facebook, Twitter, Pinterest, and a "Copy Link" button.
    *   [ ] **Frontend Logic:** Implement the functionality for each button to open the respective social sharing dialog with a pre-populated link to the current costume page.
    *   [ ] **Backend/SSR (or Frontend Head Management):** For each costume detail page, dynamically generate Open Graph meta tags (`og:title`, `og:description`, `og:image`, `og:url`) in the HTML `<head>` so that shared links have a rich preview on social media platforms.

---

### **Epic: Advanced Seller Tools & Analytics**

This epic provides sellers with data and tools to better understand how their listings are performing.

*   **Story: As a seller, I want to see basic analytics for my listings.**
    *   [ ] **Database:** Add new integer columns `view_count` and `favorite_count` to the `costumes` table, with a default value of 0.
    *   [ ] **Backend API:** Create a new endpoint, `POST /api/v1/costumes/:id/view`, which increments the `view_count` for a costume.
    *   [ ] **Frontend Logic:** Call the `POST /api/v1/costumes/:id/view` endpoint from the costume detail page component when it mounts (e.g., in a `useEffect` hook).
    *   [ ] **Backend Logic:** Implement logic to prevent `view_count` inflation (e.g., by logging views by user ID or IP address in a temporary cache like Redis to only count one view per user per day).
    *   [ ] **Backend Logic:** Modify the `POST` and `DELETE` favorite endpoints to also increment/decrement the `favorite_count` on the `costumes` table.
    *   [ ] **UI/UX:** On the seller's "My Listings" dashboard, display the `view_count` and `favorite_count` for each active listing.
    *   [ ] **Backend API:** Ensure the `GET /api/v1/users/me/costumes` endpoint includes these new analytics fields in its response.

---

### **Epic: Platform Health, Security & Compliance**

This epic covers crucial non-functional requirements for ensuring the platform is secure, performant, and compliant with legal standards.

*   **Story: As a user, I need a formal way to report a problem with an order.**
    *   [ ] **Database:** Create a `disputes` table (`id`, `order_id` (FK), `reporter_id` (FK), `reason` (TEXT), `status` (ENUM: 'open', 'under_review', 'resolved'), `created_at`, `updated_at`).
    *   [ ] **UI/UX:** On the "My Orders" page, add a "Report Problem" button next to each order. This button should only be active for a set period after purchase (e.g., 30 days).
    *   [ ] **Frontend:** Create a "Report Problem" form that captures the reason for the dispute.
    *   [ ] **Backend API:** Create an endpoint `POST /api/v1/disputes` to handle the submission of this form.
    *   [ ] **Backend Logic:** The endpoint must validate that the user reporting the problem is the buyer associated with the order.
    *   [ ] **Notifications:** Set up an internal email notification to the admin team whenever a new dispute is created.
    *   [ ] **UI/UX (Admin):** Add a "Disputes" section to the admin dashboard where admins can view and manage the status of all disputes.

*   **Story: As a developer, I need to secure the API against common threats.**
    *   [ ] **Backend:** Implement API rate limiting using a library (e.g., `express-rate-limit`) on authentication endpoints (`/login`, `/register`, `/forgot-password`) to prevent brute-force attacks.
    *   [ ] **Backend:** Configure Cross-Origin Resource Sharing (CORS) to only accept requests from the official frontend domain.
    *   [ ] **Backend:** Implement a middleware that sanitizes all user-provided input to protect against Cross-Site Scripting (XSS) attacks.
    *   [ ] **Backend:** Use a library like `helmet` (for Express.js) to set various security-related HTTP headers.
    *   [ ] **Backend:** Ensure all API endpoints that modify data are protected and can only be accessed by authenticated and authorized users.

*   **Story: As a user, I want the website to load quickly, especially the images.**
    *   [ ] **Backend/Image Upload Logic:** Integrate an image processing library (e.g., Sharp for Node.js).
    *   [ ] **Backend Logic:** When a seller uploads an image, automatically:
        *   1. Resize the original image to a max width/height (e.g., 1920px) to cap file size.
        *   2. Convert the image to a modern format like WebP.
        *   3. Generate multiple sizes (e.g., thumbnail: 200px, medium: 600px, large: 1200px).
        *   4. Store all versions in the cloud storage bucket.
    *   [ ] **Frontend:** On all listing grids and pages, use the `<picture>` element or the `srcset` attribute on `<img>` tags to allow the browser to download the most appropriately sized image for the user's viewport.
    *   [ ] **Frontend:** Implement lazy loading for images that are below the fold to improve initial page load time.
    *   [ ] **Backend:** Implement a caching strategy (e.g., Redis) for frequently accessed, non-dynamic database queries.

*   **Story: As a user, I want my rights respected regarding cookies and accessibility.**
    *   [ ] **UI/UX:** Design a simple, non-intrusive cookie consent banner.
    *   [ ] **Frontend:** Implement the cookie banner. It should not allow non-essential cookies to be set until the user gives consent.
    *   [ ] **Legal:** Create a detailed "Cookie Policy" page explaining the types of cookies used.
    *   [ ] **Frontend (Accessibility):** Ensure all form inputs have associated `<label>` tags.
    *   [ ] **Frontend (Accessibility):** Ensure all images have descriptive `alt` text. For user-uploaded images, use the costume title as a default if no alt text is provided.
    *   [ ] **Frontend (Accessibility):** Ensure the entire site can be navigated and used with only a keyboard. Pay special attention to modals and dropdowns.
    *   [ ] **Frontend (Accessibility):** Use semantic HTML5 elements (`<nav>`, `<main>`, `<header>`, `<footer>`, `<button>`) throughout the application.
    *   [ ] **Frontend (Accessibility):** Check the entire application for sufficient color contrast to meet WCAG AA standards.